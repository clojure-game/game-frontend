{
"version":3,
"file":"goog.crypt.base64.js",
"lineCount":179,
"mappings":"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",
"sources":["goog/crypt/base64.js"],
"sourcesContent":["/**\n * @license\n * Copyright The Closure Library Authors.\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Base64 en/decoding. Not much to say here except that we\n * work with decoded values in arrays of bytes. By \"byte\" I mean a number\n * in [0, 255].\n */\n\ngoog.provide('goog.crypt.base64');\n\ngoog.require('goog.asserts');\ngoog.require('goog.crypt');\ngoog.require('goog.string.internal');\ngoog.require('goog.userAgent');\ngoog.require('goog.userAgent.product');\n\n/**\n * Default alphabet, shared between alphabets. Only 62 characters.\n * @private {string}\n */\ngoog.crypt.base64.DEFAULT_ALPHABET_COMMON_ = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n    'abcdefghijklmnopqrstuvwxyz' +\n    '0123456789';\n\n\n/**\n * Alphabet characters for Alphabet.DEFAULT encoding.\n * For characters without padding, please consider using\n * `goog.crypt.baseN.BASE_64` instead.\n *\n * @type {string}\n */\ngoog.crypt.base64.ENCODED_VALS =\n    goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + '+/=';\n\n\n/**\n * Alphabet characters for Alphabet.WEBSAFE_DOT_PADDING encoding.\n * The dot padding is no Internet Standard, according to RFC 4686.\n * https://tools.ietf.org/html/rfc4648\n * For characters without padding, please consider using\n * `goog.crypt.baseN.BASE_64_URL_SAFE` instead.\n *\n * @type {string}\n */\ngoog.crypt.base64.ENCODED_VALS_WEBSAFE =\n    goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + '-_.';\n\n\n/**\n * Alphabets for Base64 encoding\n * Alphabets with no padding character are for encoding without padding.\n * About the alphabets, please refer to RFC 4686.\n * https://tools.ietf.org/html/rfc4648\n * @enum {number}\n */\ngoog.crypt.base64.Alphabet = {\n  /** Section 4 \"base64\". */\n  DEFAULT: 0,\n  /** Section 4 \"base64\", omitting padding per Section 3.2. */\n  NO_PADDING: 1,\n  /** Section 5 \"base64url\". */\n  WEBSAFE: 2,\n  /** Like WEBSAFE, but with non-standard '.' padding character. */\n  WEBSAFE_DOT_PADDING: 3,\n  /** Section 5 \"base64url\", omitting padding per Section 3.2. */\n  WEBSAFE_NO_PADDING: 4,\n};\n\n\n/**\n * Padding chars for Base64 encoding\n * @const {string}\n * @private\n */\ngoog.crypt.base64.paddingChars_ = '=.';\n\n\n/**\n * Check if a character is a padding character\n *\n * @param {string} char\n * @return {boolean}\n * @private\n */\ngoog.crypt.base64.isPadding_ = function(char) {\n  'use strict';\n  return goog.string.internal.contains(goog.crypt.base64.paddingChars_, char);\n};\n\n\n// Static lookup maps, lazily populated by init_()\n\n/**\n * For each `Alphabet`, maps from bytes to characters.\n *\n * @see https://jsperf.com/char-lookups\n * @type {!Object<!goog.crypt.base64.Alphabet, !Array<string>>}\n * @private\n */\ngoog.crypt.base64.byteToCharMaps_ = {};\n\n/**\n * Maps characters to bytes.\n *\n * This map is used for all alphabets since, across alphabets, common chars\n * always map to the same byte.\n *\n * `null` indicates `init` has not yet been called.\n *\n * @type {?Object<string, number>}\n * @private\n */\ngoog.crypt.base64.charToByteMap_ = null;\n\n\n/**\n * White list of implementations with known-good native atob and btoa functions.\n * Listing these explicitly (via the ASSUME_* wrappers) benefits dead-code\n * removal in per-browser compilations.\n * @private {boolean}\n */\ngoog.crypt.base64.ASSUME_NATIVE_SUPPORT_ =\n    goog.userAgent.GECKO || goog.userAgent.WEBKIT;\n\n\n/**\n * Does this browser have a working btoa function?\n * @private {boolean}\n */\ngoog.crypt.base64.HAS_NATIVE_ENCODE_ =\n    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||\n    typeof (goog.global.btoa) == 'function';\n\n\n/**\n * Does this browser have a working atob function?\n * We blacklist known-bad implementations:\n *  - IE (10+) added atob() but it does not tolerate whitespace on the input.\n * @private {boolean}\n */\ngoog.crypt.base64.HAS_NATIVE_DECODE_ =\n    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ ||\n    (!goog.userAgent.product.SAFARI && !goog.userAgent.IE &&\n     typeof (goog.global.atob) == 'function');\n\n\n/**\n * Base64-encode an array of bytes.\n *\n * @param {Array<number>|Uint8Array} input An array of bytes (numbers with\n *     value in [0, 255]) to encode.\n * @param {!goog.crypt.base64.Alphabet=} alphabet Base 64 alphabet to\n *     use in encoding. Alphabet.DEFAULT is used by default.\n * @return {string} The base64 encoded string.\n */\ngoog.crypt.base64.encodeByteArray = function(input, alphabet) {\n  'use strict';\n  // Assert avoids runtime dependency on goog.isArrayLike, which helps reduce\n  // size of jscompiler output, and which yields slight performance increase.\n  goog.asserts.assert(\n      goog.isArrayLike(input), 'encodeByteArray takes an array as a parameter');\n\n  if (alphabet === undefined) {\n    alphabet = goog.crypt.base64.Alphabet.DEFAULT;\n  }\n  goog.crypt.base64.init_();\n\n  const byteToCharMap = goog.crypt.base64.byteToCharMaps_[alphabet];\n  const output = new Array(Math.floor(input.length / 3));\n  const paddingChar = byteToCharMap[64] || '';\n\n  // Add all blocks for which we have four output bytes.\n  let inputIdx = 0;\n  let outputIdx = 0;\n  for (; inputIdx < input.length - 2; inputIdx += 3) {\n    const byte1 = input[inputIdx];\n    const byte2 = input[inputIdx + 1];\n    const byte3 = input[inputIdx + 2];\n\n    const outChar1 = byteToCharMap[byte1 >> 2];\n    const outChar2 = byteToCharMap[((byte1 & 0x03) << 4) | (byte2 >> 4)];\n    const outChar3 = byteToCharMap[((byte2 & 0x0F) << 2) | (byte3 >> 6)];\n    const outChar4 = byteToCharMap[byte3 & 0x3F];\n\n    output[outputIdx++] = ((('' + outChar1) + outChar2) + outChar3) + outChar4;\n  }\n\n  // Add our trailing block, in which case we can skip computations relating to\n  // byte3/outByte4.\n  let byte2 = 0;\n  let outChar3 = paddingChar;\n  switch (input.length - inputIdx) {\n    case 2:\n      byte2 = input[inputIdx + 1];\n      outChar3 = byteToCharMap[(byte2 & 0x0F) << 2] || paddingChar;\n      // fall through.\n    case 1:\n      const byte1 = input[inputIdx];\n      const outChar1 = byteToCharMap[byte1 >> 2];\n      const outChar2 = byteToCharMap[((byte1 & 0x03) << 4) | (byte2 >> 4)];\n\n      output[outputIdx] =\n          ((('' + outChar1) + outChar2) + outChar3) + paddingChar;\n      // fall through.\n    default:\n      // We've ended on a block, so we have no more bytes to encode.\n  }\n\n  return output.join('');\n};\n\n\n/**\n * Base64-encode a binary string.  Note that binary strings are discouraged now\n * that Uint8Array is available on all supported browsers.  Users are encouraged\n * to strongly consider `encodeByteArray`.  This method is likely to be\n * deprecated at some point in favor of the Uint8Array version.\n *\n * @param {string} input A string to encode.  Must not contain characters\n *     outside of the Latin-1 range (i.e. charCode > 255).\n * @param {!goog.crypt.base64.Alphabet=} alphabet Base 64 alphabet to\n *     use in encoding. Alphabet.DEFAULT is used by default.\n * @return {string} The base64 encoded string.\n */\ngoog.crypt.base64.encodeBinaryString = function(input, alphabet) {\n  return goog.crypt.base64.encodeString(input, alphabet, true);\n};\n\n\n/**\n * Base64-encode a binary string.\n *\n * @param {string} input A string to encode.  Must not contain characters\n *     outside of the Latin-1 range (i.e. charCode > 255).\n * @param {!goog.crypt.base64.Alphabet=} alphabet Base 64 alphabet to\n *     use in encoding. Alphabet.DEFAULT is used by default.\n * @param {boolean=} throwSync Whether to throw synchronously on unicode.  Note\n *     that if not using a custom alphabet, the throw will always be sync.\n * @return {string} The base64 encoded string.\n */\ngoog.crypt.base64.encodeString = function(input, alphabet, throwSync) {\n  'use strict';\n  // Shortcut for browsers that implement\n  // a native base64 encoder in the form of \"btoa/atob\"\n  if (goog.crypt.base64.HAS_NATIVE_ENCODE_ && !alphabet) {\n    return goog.global.btoa(input);\n  }\n  return goog.crypt.base64.encodeByteArray(\n      goog.crypt.stringToByteArray(input, throwSync), alphabet);\n};\n\n\n/**\n * Base64-encode a text string.  Non-ASCII characters (charCode > 127) will be\n * encoded as UTF-8.\n *\n * @param {string} input A string to encode.\n * @param {!goog.crypt.base64.Alphabet=} alphabet Base 64 alphabet to\n *     use in encoding. Alphabet.DEFAULT is used by default.\n * @return {string} The base64 encoded string.\n */\ngoog.crypt.base64.encodeStringUtf8 = function(input, alphabet) {\n  return goog.crypt.base64.encodeText(input, alphabet);\n};\n\n\n/**\n * Base64-encode a text string.  Non-ASCII characters (charCode > 127) will be\n * encoded as UTF-8.\n *\n * @param {string} input A string to encode.\n * @param {!goog.crypt.base64.Alphabet=} alphabet Base 64 alphabet to\n *     use in encoding. Alphabet.DEFAULT is used by default.\n * @return {string} The base64 encoded string.\n */\ngoog.crypt.base64.encodeText = function(input, alphabet) {\n  'use strict';\n  // Shortcut for browsers that implement\n  // a native base64 encoder in the form of \"btoa/atob\"\n  if (goog.crypt.base64.HAS_NATIVE_ENCODE_ && !alphabet) {\n    return goog.global.btoa(unescape(encodeURIComponent(input)));\n  }\n  return goog.crypt.base64.encodeByteArray(\n      goog.crypt.stringToUtf8ByteArray(input), alphabet);\n};\n\n\n/**\n * Base64-decode a string into a binary bytestring.  Note that binary strings\n * are discouraged now that Uint8Array is available on all supported browsers.\n * Users are encouraged to strongly consider `decodeStringToUint8Array`.  This\n * method is likely to be deprecated at some point in favor of the Uint8Array\n * version.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @param {boolean=} useCustomDecoder True indicates the custom decoder is used,\n *     which supports alternative alphabets. Note that passing false may still\n *     use the custom decoder on browsers without native support.\n * @return {string} string representing the decoded value.\n */\ngoog.crypt.base64.decodeToBinaryString = function(input, useCustomDecoder) {\n  'use strict';\n  // Shortcut for browsers that implement\n  // a native base64 encoder in the form of \"btoa/atob\"\n  if (goog.crypt.base64.HAS_NATIVE_DECODE_ && !useCustomDecoder) {\n    return goog.global.atob(input);\n  }\n  var output = '';\n  function pushByte(b) {\n    output += String.fromCharCode(b);\n  }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  return output;\n};\n\n\n/**\n * Base64-decode a string into a binary bytestring.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @param {boolean=} useCustomDecoder True indicates the custom decoder is used,\n *     which supports alternative alphabets. Note that passing false may still\n *     use the custom decoder on browsers without native support.\n * @return {string} string representing the decoded value.\n */\ngoog.crypt.base64.decodeString = goog.crypt.base64.decodeToBinaryString;\n\n\n/**\n * Base64-decode a string.  The input should be the result of a double-encoding\n * a unicode string: first the unicode characters (>127) are encoded as UTF-8\n * bytes, and then the resulting bytes are base64-encoded.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @param {boolean=} useCustomDecoder True indicates the custom decoder is used,\n *     which supports alternative alphabets. Note that passing false may still\n *     use the custom decoder on browsers without native support.\n * @return {string} string representing the decoded value.\n */\ngoog.crypt.base64.decodeStringUtf8 = function(input, useCustomDecoder) {\n  return goog.crypt.base64.decodeToText(input, useCustomDecoder);\n};\n\n\n/**\n * Base64-decode a string.  The input should be the result of a double-encoding\n * a unicode string: first the unicode characters (>127) are encoded as UTF-8\n * bytes, and then the resulting bytes are base64-encoded.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @param {boolean=} useCustomDecoder True indicates the custom decoder is used,\n *     which supports alternative alphabets. Note that passing false may still\n *     use the custom decoder on browsers without native support.\n * @return {string} string representing the decoded value.\n */\ngoog.crypt.base64.decodeToText = function(input, useCustomDecoder) {\n  'use strict';\n  return decodeURIComponent(\n      escape(goog.crypt.base64.decodeString(input, useCustomDecoder)));\n};\n\n\n/**\n * Base64-decode a string to an Array of numbers.\n *\n * In base-64 decoding, groups of four characters are converted into three\n * bytes.  If the encoder did not apply padding, the input length may not\n * be a multiple of 4.\n *\n * In this case, the last group will have fewer than 4 characters, and\n * padding will be inferred.  If the group has one or two characters, it decodes\n * to one byte.  If the group has three characters, it decodes to two bytes.\n *\n * TODO(sdh): We may want to consider renaming this to `decodeToByteArray` for\n * consistency with `decodeToText`/`decodeToBinaryString`.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @param {boolean=} opt_ignored Unused parameter, retained for compatibility.\n * @return {!Array<number>} bytes representing the decoded value.\n */\ngoog.crypt.base64.decodeStringToByteArray = function(input, opt_ignored) {\n  'use strict';\n  var output = [];\n  function pushByte(b) {\n    output.push(b);\n  }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  return output;\n};\n\n\n/**\n * Base64-decode a string to a Uint8Array.\n *\n * Note that Uint8Array is not supported on older browsers, e.g. IE < 10.\n * @see http://caniuse.com/uint8array\n *\n * In base-64 decoding, groups of four characters are converted into three\n * bytes.  If the encoder did not apply padding, the input length may not\n * be a multiple of 4.\n *\n * In this case, the last group will have fewer than 4 characters, and\n * padding will be inferred.  If the group has one or two characters, it decodes\n * to one byte.  If the group has three characters, it decodes to two bytes.\n *\n * TODO(sdh): We may want to consider renaming this to `decodeToUint8Array` for\n * consistency with `decodeToText`/`decodeToBinaryString`.\n *\n * @param {string} input Input to decode. Any whitespace is ignored, and the\n *     input maybe encoded with either supported alphabet (or a mix thereof).\n * @return {!Uint8Array} bytes representing the decoded value.\n */\ngoog.crypt.base64.decodeStringToUint8Array = function(input) {\n  'use strict';\n  var len = input.length;\n  // Approximate the length of the array needed for output.\n  // Our method varies according to the format of the input, which we can\n  // consider in three categories:\n  //   A) well-formed with proper padding\n  //   B) well-formed without any padding\n  //   C) not-well-formed, either with extra whitespace in the middle or with\n  //      extra padding characters.\n  //\n  //  In the case of (A), (length * 3 / 4) will result in an integer number of\n  //  bytes evenly divisible by 3, and we need only subtract bytes according to\n  //  the padding observed.\n  //\n  //  In the case of (B), (length * 3 / 4) will result in a non-integer number\n  //  of bytes, or not evenly divisible by 3. (If the result is evenly divisible\n  //  by 3, it's well-formed with the proper amount of padding [0 padding]).\n  //  This approximation can become exact by rounding down.\n  //\n  //  In the case of (C), the only way to get the length is to walk the full\n  //  length of the string to consider each character. This is handled by\n  //  tracking the number of bytes added to the array and using subarray to\n  //  trim the array back down to size.\n  var approxByteLength = len * 3 / 4;\n  if (approxByteLength % 3) {\n    // The string isn't complete, either because it didn't include padding, or\n    // because it has extra white space.\n    // In either case, we won't generate more bytes than are completely encoded,\n    // so rounding down is appropriate to have a buffer at least as large as\n    // output.\n    approxByteLength = Math.floor(approxByteLength);\n  } else if (goog.crypt.base64.isPadding_(input[len - 1])) {\n    // The string has a round length, and has some padding.\n    // Reduce the byte length according to the quantity of padding.\n    if (goog.crypt.base64.isPadding_(input[len - 2])) {\n      approxByteLength -= 2;\n    } else {\n      approxByteLength -= 1;\n    }\n  }\n  var output = new Uint8Array(approxByteLength);\n  var outLen = 0;\n  function pushByte(b) {\n    output[outLen++] = b;\n  }\n\n  goog.crypt.base64.decodeStringInternal_(input, pushByte);\n\n  // Trim unused trailing bytes if necessary, this only happens if the input\n  // included extra whitespace or extra padding that caused our estimate to be\n  // too large (this is uncommon).\n  //\n  // It would be correct to simply always call subarray, but we avoid doing so\n  // to avoid potential poor performance from chrome.\n  // See https://bugs.chromium.org/p/v8/issues/detail?id=7161\n  return outLen !== approxByteLength ? output.subarray(0, outLen) : output;\n};\n\n\n/**\n * @param {string} input Input to decode.\n * @param {function(number):void} pushByte result accumulator.\n * @private\n */\ngoog.crypt.base64.decodeStringInternal_ = function(input, pushByte) {\n  'use strict';\n  goog.crypt.base64.init_();\n\n  var nextCharIndex = 0;\n  /**\n   * @param {number} default_val Used for end-of-input.\n   * @return {number} The next 6-bit value, or the default for end-of-input.\n   */\n  function getByte(default_val) {\n    while (nextCharIndex < input.length) {\n      var ch = input.charAt(nextCharIndex++);\n      var b = goog.crypt.base64.charToByteMap_[ch];\n      if (b != null) {\n        return b;  // Common case: decoded the char.\n      }\n      if (!goog.string.internal.isEmptyOrWhitespace(ch)) {\n        throw new Error('Unknown base64 encoding at char: ' + ch);\n      }\n      // We encountered whitespace: loop around to the next input char.\n    }\n    return default_val;  // No more input remaining.\n  }\n\n  while (true) {\n    var byte1 = getByte(-1);\n    var byte2 = getByte(0);\n    var byte3 = getByte(64);\n    var byte4 = getByte(64);\n\n    // The common case is that all four bytes are present, so if we have byte4\n    // we can skip over the truncated input special case handling.\n    if (byte4 === 64) {\n      if (byte1 === -1) {\n        return;  // Terminal case: no input left to decode.\n      }\n      // Here we know an intermediate number of bytes are missing.\n      // The defaults for byte2, byte3 and byte4 apply the inferred padding\n      // rules per the public API documentation. i.e: 1 byte\n      // missing should yield 2 bytes of output, but 2 or 3 missing bytes yield\n      // a single byte of output. (Recall that 64 corresponds the padding char).\n    }\n\n    var outByte1 = (byte1 << 2) | (byte2 >> 4);\n    pushByte(outByte1);\n\n    if (byte3 != 64) {\n      var outByte2 = ((byte2 << 4) & 0xF0) | (byte3 >> 2);\n      pushByte(outByte2);\n\n      if (byte4 != 64) {\n        var outByte3 = ((byte3 << 6) & 0xC0) | byte4;\n        pushByte(outByte3);\n      }\n    }\n  }\n};\n\n\n/**\n * Lazy static initialization function. Called before\n * accessing any of the static map variables.\n * @private\n */\ngoog.crypt.base64.init_ = function() {\n  'use strict';\n  if (goog.crypt.base64.charToByteMap_) {\n    return;\n  }\n  goog.crypt.base64.charToByteMap_ = {};\n\n  // We want quick mappings back and forth, so we precompute encoding maps.\n\n  /** @type {!Array<string>} */\n  var commonChars = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split('');\n  var specialChars = [\n    '+/=',  // DEFAULT\n    '+/',   // NO_PADDING\n    '-_=',  // WEBSAFE\n    '-_.',  // WEBSAFE_DOT_PADDING\n    '-_',   // WEBSAFE_NO_PADDING\n  ];\n\n  for (var i = 0; i < 5; i++) {\n    // `i` is each value of the `goog.crypt.base64.Alphabet` enum\n    var chars = commonChars.concat(specialChars[i].split(''));\n\n    // Sets byte-to-char map\n    goog.crypt.base64\n        .byteToCharMaps_[/** @type {!goog.crypt.base64.Alphabet} */ (i)] =\n        chars;\n\n    // Sets char-to-byte map\n    for (var j = 0; j < chars.length; j++) {\n      var char = chars[j];\n\n      var existingByte = goog.crypt.base64.charToByteMap_[char];\n      if (existingByte === undefined) {\n        goog.crypt.base64.charToByteMap_[char] = j;\n      } else {\n        goog.asserts.assert(existingByte === j);\n      }\n    }\n  }\n};\n"],
"names":["goog","provide","require","crypt","base64","DEFAULT_ALPHABET_COMMON_","ENCODED_VALS","ENCODED_VALS_WEBSAFE","Alphabet","DEFAULT","NO_PADDING","WEBSAFE","WEBSAFE_DOT_PADDING","WEBSAFE_NO_PADDING","paddingChars_","isPadding_","goog.crypt.base64.isPadding_","char","string","internal","contains","byteToCharMaps_","charToByteMap_","ASSUME_NATIVE_SUPPORT_","userAgent","GECKO","WEBKIT","HAS_NATIVE_ENCODE_","global","btoa","HAS_NATIVE_DECODE_","product","SAFARI","IE","atob","encodeByteArray","goog.crypt.base64.encodeByteArray","input","alphabet","asserts","assert","isArrayLike","undefined","init_","byteToCharMap","output","Array","Math","floor","length","paddingChar","inputIdx","outputIdx","byte1","byte2","byte3","outChar1","outChar2","outChar3","outChar4","join","encodeBinaryString","goog.crypt.base64.encodeBinaryString","encodeString","goog.crypt.base64.encodeString","throwSync","stringToByteArray","encodeStringUtf8","goog.crypt.base64.encodeStringUtf8","encodeText","goog.crypt.base64.encodeText","unescape","encodeURIComponent","stringToUtf8ByteArray","decodeToBinaryString","goog.crypt.base64.decodeToBinaryString","useCustomDecoder","pushByte","b","String","fromCharCode","decodeStringInternal_","decodeString","decodeStringUtf8","goog.crypt.base64.decodeStringUtf8","decodeToText","goog.crypt.base64.decodeToText","decodeURIComponent","escape","decodeStringToByteArray","goog.crypt.base64.decodeStringToByteArray","opt_ignored","push","decodeStringToUint8Array","goog.crypt.base64.decodeStringToUint8Array","len","approxByteLength","Uint8Array","outLen","subarray","goog.crypt.base64.decodeStringInternal_","nextCharIndex","getByte","default_val","ch","charAt","isEmptyOrWhitespace","Error","byte4","outByte1","outByte2","outByte3","goog.crypt.base64.init_","commonChars","split","specialChars","i","chars","concat","j","existingByte"]
}
